package cn.csu.list;

import static org.junit.Assert.*;

import java.util.HashMap;
import java.util.Map.Entry;
import java.util.Set;

import org.junit.AfterClass;
import org.junit.Test;

public class HashMapTest {

	@AfterClass
	public static void tearDownAfterClass() throws Exception {
	}

	@Test
	public void testClone() {
		fail("Not yet implemented");
	}

	@Test
	public void testSize() {
		fail("Not yet implemented");
	}

	@Test
	public void testIsEmpty() {
		fail("Not yet implemented");
	}

	@Test
	public void testContainsValue() {
		fail("Not yet implemented");
	}

	@Test
	public void testContainsKey() {
		fail("Not yet implemented");
	}

	@Test
	public void testGet() {
		fail("Not yet implemented");
	}

	@Test
	public void testPut() {
		fail("Not yet implemented");
	}

	@Test
	public void testRemoveObject() {
		fail("Not yet implemented");
	}

	@Test
	public void testPutAll() {
		fail("Not yet implemented");
	}

	@Test
	public void testClear() {
		fail("Not yet implemented");
	}

	@Test
	public void testKeySet() {
		fail("Not yet implemented");
	}

	@Test
	public void testValues() {
		fail("Not yet implemented");
	}

	@Test
	public void testEntrySet() {
		fail("Not yet implemented");
		Set<Entry<Object, Object>> set = new HashMap<>().entrySet();
		for(Entry<Object, Object> s:set) {
			s.getValue();
		}
	}

	@Test
	public void testHash() {
		fail("Not yet implemented");
	}

	@Test
	public void testComparableClassFor() {
		fail("Not yet implemented");
	}

	@Test
	public void testCompareComparables() {
		fail("Not yet implemented");
	}

	@Test
	public void testTableSizeFor() {
		fail("Not yet implemented");
	}

	@Test
	public void testHashMapIntFloat() {
		fail("Not yet implemented");
	}

	@Test
	public void testHashMapInt() {
		fail("Not yet implemented");
	}

	@Test
	public void testHashMap() {
		fail("Not yet implemented");
	}

	@Test
	public void testHashMapMapOfQextendsKQextendsV() {
		fail("Not yet implemented");
	}

	@Test
	public void testPutMapEntries() {
		fail("Not yet implemented");
	}

	@Test
	public void testGetNode() {
		fail("Not yet implemented");
	}

	@Test
	public void testPutVal() {
		fail("Not yet implemented");
	}

	@Test
	public void testResize() {
		fail("Not yet implemented");
	}

	@Test
	public void testTreeifyBin() {
		fail("Not yet implemented");
	}

	@Test
	public void testRemoveNode() {
		fail("Not yet implemented");
	}

	@Test
	public void testGetOrDefault() {
		fail("Not yet implemented");
	}

	@Test
	public void testPutIfAbsent() {
		fail("Not yet implemented");
	}

	@Test
	public void testRemoveObjectObject() {
		fail("Not yet implemented");
	}

	@Test
	public void testReplaceKVV() {
		fail("Not yet implemented");
	}

	@Test
	public void testReplaceKV() {
		fail("Not yet implemented");
	}

	@Test
	public void testComputeIfAbsent() {
		fail("Not yet implemented");
	}

	@Test
	public void testComputeIfPresent() {
		fail("Not yet implemented");
	}

	@Test
	public void testCompute() {
		fail("Not yet implemented");
	}

	@Test
	public void testMerge() {
		fail("Not yet implemented");
	}

	@Test
	public void testForEach() {
		fail("Not yet implemented");
	}

	@Test
	public void testReplaceAll() {
		fail("Not yet implemented");
	}

	@Test
	public void testLoadFactor() {
		fail("Not yet implemented");
	}

	@Test
	public void testCapacity() {
		fail("Not yet implemented");
	}

	@Test
	public void testNewNode() {
		fail("Not yet implemented");
	}

	@Test
	public void testReplacementNode() {
		fail("Not yet implemented");
	}

	@Test
	public void testNewTreeNode() {
		fail("Not yet implemented");
	}

	@Test
	public void testReplacementTreeNode() {
		fail("Not yet implemented");
	}

	@Test
	public void testReinitialize() {
		fail("Not yet implemented");
	}

	@Test
	public void testAfterNodeAccess() {
		fail("Not yet implemented");
	}

	@Test
	public void testAfterNodeInsertion() {
		fail("Not yet implemented");
	}

	@Test
	public void testAfterNodeRemoval() {
		fail("Not yet implemented");
	}

	@Test
	public void testInternalWriteEntries() {
		fail("Not yet implemented");
	}

}
